{ "switches" : [ {"defaultValue":"2.5","name":"AOTInliningDepthToSizeRate","prefix":"-XX:","type":"Double"},
{"defaultValue":"300","name":"AOTInliningSizeMaximum","prefix":"-XX:","type":"Integer"},
{"defaultValue":"50","name":"AOTInliningSizeMinimum","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Generate verify oop checks in AOT code\n<\/pre>","name":"AOTVerifyOops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Enables instruction profiling on assembler level. Valid values are a\ncomma separated list of supported instructions. Compare with subclasses\nof Assembler.InstructionCounter.\n<\/pre>","name":"ASMInstructionProfiling","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Abort VM with SIGILL if benchmark counters controlled by the\n(Generic|Timed|Benchmark)DynamicCounters\noption overflow. This feature is only supported on AMD64.\nWARNING: No descriptive error message will be printed! In case of an overflow,\nmanual inspection of the emitted code is required.\n<\/pre>","name":"AbortOnBenchmarkCounterOverflow","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"-1","description":"<pre>Overwrites the available number of processors provided by the OS. Any\nvalue <= 0 means using the processor count from the OS.\n<\/pre>","name":"ActiveProcessorCount","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>File to which aggregated metrics are dumped at shutdown. A CSV format\nis used if the file ends with .csv otherwise a more human readable\nformat is used. If not specified, metrics are dumped to the console.\n<\/pre>","name":"AggregatedMetricsFile","prefix":"-XX:","type":"String"},
{"defaultValue":"true","description":"<pre>Model all array type flows using a unique elements type flow\nabstraction.\n<\/pre>","name":"AliasArrayTypeFlows","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"1048576","description":"<pre>The minimum size in bytes required for printing an allocation profiling\nentry\n<\/pre>","name":"AllocationProfilingThreshold","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>A context sensitive heap means that each heap allocated object is\nmodeled by using at least the allocation site.\n<\/pre>","name":"AllocationSiteSensitiveHeap","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Unconditionally inline intrinsics\n<\/pre>","name":"AlwaysInlineIntrinsics","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"AlwaysInlineVTableStubs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Force all freshly committed pages to be pre-touched\n<\/pre>","name":"AlwaysPreTouch","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"insens\"","description":"<pre>Controls the static analysis context sensitivity. Available values:\ninsens (context insensitive analysis), allocsens (context insensitive\nanalysis, context insensitive heap, allocation site sensitive heap),\n_1obj (1 object sensitive analysis with a context insensitive heap),\n_2obj1h (2 object sensitive with a 1 context sensitive heap)\n<\/pre>","name":"AnalysisContextSensitivity","prefix":"-XX:","type":"String"},
{"defaultValue":"8","description":"<pre>The maximum size of type and method profiles returned by the static\nanalysis. -1 indicates no limitation.\n<\/pre>","name":"AnalysisSizeCutoff","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Analysis results statistics file.\n<\/pre>","name":"AnalysisStatisticsFile","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Record stack trace along with scoped foreign object reference wrappers to debug issue with a wrapper being used after its scope has closed.\n<\/pre>","name":"AuditHandles","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"120","description":"<pre>The base target spending used to estimate the inlining threshold; the\nhigher, the likelier it is to inline.\n<\/pre>","name":"BaseTargetSpending","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Use a cutoff to print only most significant counters.\n<\/pre>","name":"BenchmarkCounterPrintingCutoff","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Dump dynamic counters\n<\/pre>","name":"BenchmarkCountersDumpDynamic","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Dump static counters\n<\/pre>","name":"BenchmarkCountersDumpStatic","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>File to which benchmark counters are dumped. A CSV format is used if\nthe file ends with .csv otherwise a more human readable format is used.\nThe fields in the CSV format are: category, group, name, value\n<\/pre>","name":"BenchmarkCountersFile","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Turn on the benchmark counters. The format of this option is:\n          \n  (err|out),start pattern,end pattern\n  \nStart counting when the start pattern matches on the given stream and stop when the end pattern occurs.\nYou can use \"~\" to match 1 or more digits.\nExamples:\n          \n  err, starting =====, PASSED in\n  out,Iteration ~ (~s) begins:,Iteration ~ (~s) ends:\n  \nThe first pattern matches DaCapo output and the second matches SPECjvm2008 output.\n          \nAs a more detailed example, here are the options to use for getting statistics\nabout allocations within the DaCapo pmd benchmark:\n          \n  -XX:JVMCICounterSize=<value> -XX:-JVMCICountersExcludeCompiler \\\n  -Dgraal.BenchmarkDynamicCounters=\"err, starting ====, PASSED in \" \\\n  -Dgraal.ProfileAllocations=true\n  \nThe JVMCICounterSize value depends on the granularity of the profiling -\n10000 should be sufficient. Omit JVMCICountersExcludeCompiler to exclude\ncounting allocations on the compiler threads.\nThe counters can be further configured by the ProfileAllocationsContext option.\n          \nWe highly recommend the use of -Dgraal.AbortOnBenchmarkCounterOverflow=true to\ndetect counter overflows eagerly.\n<\/pre>","name":"BenchmarkDynamicCounters","prefix":"-XX:","type":"String"},
{"defaultValue":"512","description":"<pre>Minimum amount of bytes when block zeroing used. (SPARC only)\n<\/pre>","name":"BlockZeroingLowLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Do not compile anything on bootstrap but just initialize the compiler.\n<\/pre>","name":"BootstrapInitializeOnly","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"15.0","description":"<pre>Maximum time in minutes to spend bootstrapping (0 to disable this\nlimit).\n<\/pre>","name":"BootstrapTimeout","prefix":"-XX:","type":"Double"},
{"defaultValue":"0.25","description":"<pre>Ratio of the maximum compilation rate below which the bootstrap\ncompilation rate must not fall (0 or less disables monitoring).\n<\/pre>","name":"BootstrapWatchDogCriticalRateRatio","prefix":"-XX:","type":"Double"},
{"defaultValue":"true","description":"<pre>Break chained phis\n<\/pre>","name":"BreakChainedPhis","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"35000","description":"<pre>Controls the maximum number of compiler nodes that can appear in the\ncall graph\n<\/pre>","name":"CallGraphCompilerNodeLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"1200","description":"<pre>Controls the maximum size of the call graph before ceasing inlining.\n<\/pre>","name":"CallGraphSizeLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0.001","description":"<pre>Reduces the likelihood of exploring call graph subtrees that are large.\n<\/pre>","name":"CallGraphSizePenaltyCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"true","name":"CanOmitFrame","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Exclude virtual nodes when dumping canonical text for graphs.\n<\/pre>","name":"CanonicalGraphStringsCheckConstants","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Exclude virtual nodes when dumping canonical text for graphs.\n<\/pre>","name":"CanonicalGraphStringsExcludeVirtuals","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Attempts to remove object identity hashes when dumping canonical text\nfor graphs.\n<\/pre>","name":"CanonicalGraphStringsRemoveIdentities","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Clear the debug metrics after bootstrap.\n<\/pre>","name":"ClearMetricsAfterBootstrap","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Determines if a full GC collects the young generation separately or\ntogether with the old generation.\n<\/pre>","name":"CollectYoungGenerationSeparately","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Treat compilation bailouts like compilation failures.\n<\/pre>","name":"CompilationBailoutAsFailure","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>The number of compilations allowed for any method before the VM exits\n(a value of 0 means there is no limit).\n<\/pre>","name":"CompilationCountLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Exclude certain phases from compilation, either unconditionally or with\na method filter\n<\/pre>","name":"CompilationExcludePhases","prefix":"-XX:","type":"String"},
{"defaultValue":"300","description":"<pre>Time limit in seconds before a compilation expires (0 to disable the\nlimit). The compilation alarm will be implicitly disabled if assertions\nare enabled.\n<\/pre>","name":"CompilationExpirationPeriod","prefix":"-XX:","type":"Integer"},
{"defaultValue":"Silent","description":"<pre>Specifies the action to take when compilation fails.\n          \nThe accepted values are:\n    Silent  - Print nothing to the console.\n     Print  - Print a stack trace to the console.\n  Diagnose* - Retry the compilation with extra diagnostics.\n    ExitVM  - Same as Diagnose except that the VM process exits after retrying.\n    \n* If \"Diagnose\" is set compilation will be retried with extra diagnostics enabled including dumping (see file:doc-files/DumpHelp.txt). \n  In such a scenario DiagnoseDumpLevel can be used to specify the dump level (DebugContext dump levels) accordingly.\n      \n<\/pre>","name":"CompilationFailureAction","prefix":"-XX:","type":"String"},
{"defaultValue":"0","description":"<pre>Size of the reserved address space of each compilation isolate (0:\ndefault for new isolates).\n<\/pre>","name":"CompilationIsolateAddressSpaceSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"60.0","description":"<pre>Interval in seconds between a watch dog reporting stack traces for long\nrunning compilations.\n<\/pre>","name":"CompilationWatchDogStackTraceInterval","prefix":"-XX:","type":"Double"},
{"defaultValue":"0.0","description":"<pre>Delay in seconds before watch dog monitoring a compilation (0 disables\nmonitoring).\n<\/pre>","name":"CompilationWatchDogStartDelay","prefix":"-XX:","type":"Double"},
{"defaultValue":"true","description":"<pre>In tiered mode compile Graal and JVMCI using optimized first tier code.\n<\/pre>","name":"CompileGraalWithC1Only","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Activate runtime compilation in separate isolates (enable support\nduring image build with option SupportCompileInIsolates).\n<\/pre>","name":"CompileInIsolates","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Create one reusable isolate per compilation thread as opposed to one\nisolate per compilation (enable through CompileInIsolates).\n<\/pre>","name":"CompileInPerThreadReusedIsolates","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Names the compiler configuration to use. If omitted, the compiler\nconfiguration with the highest auto-selection priority is used. To see\nthe set of available configurations, supply the value 'help' to this\noption.\n<\/pre>","name":"CompilerConfiguration","prefix":"-XX:","type":"String"},
{"defaultValue":"0.006","description":"<pre>Controls the likelihood of exploring subtrees that already have a lot\nof code during inlining.\n<\/pre>","name":"CompilerNodePenaltyCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"null","description":"<pre>Selects the system compiler. This must match the getCompilerName() value returned by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. An empty string or the value \"null\" selects a compiler that will raise an exception upon receiving a compilation request.\n<\/pre>","name":"Compiler","prefix":"-XX:","type":"String"},
{"defaultValue":"0","description":"<pre>Number of threads concurrent gc will use\n<\/pre>","name":"ConcGCThreads","prefix":"-XX:","type":"Integer"},
{"defaultValue":"4","name":"ConditionalEliminationMaxIterations","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"ConditionalElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Consider the vectorizability of loop during the duplication of a merge\ninside a loop.There are rare cases where duplication can destroy\nvectorization.\n<\/pre>","name":"ConsiderVectorizableLoops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"4","description":"<pre>PullThroughPhiOptimization: Abstract cost for the creation of a new\nlive value: new values can have a negativeimpact on register\nallocation, therefore we penalize it.\n<\/pre>","name":"CostNewLiveVariable","prefix":"-XX:","type":"Integer"},
{"defaultValue":"32.0","description":"<pre>PullThroughPhiOptimization: Cost/Benefit heuristic for EE floating node\nduplication: reduce cost by a constant factor when comparing with\nrelative benefit.\n<\/pre>","name":"CostReductionFactor","prefix":"-XX:","type":"Double"},
{"defaultValue":"null","description":"<pre>Pattern for specifying scopes in which counters are enabled. See the\nDump option for the pattern syntax. An empty value enables all counters\nunconditionally.\n<\/pre>","name":"Count","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Comma separated names of counters that are enabled irrespective of the\nvalue for Count option. An empty value enables all counters\nunconditionally.\n<\/pre>","name":"Counters","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Converts an exception triggered by the CrashAt option into a fatal\nerror if a non-null pointer was passed in the _fatal option to\nJNI_CreateJavaVM. This option exists for the purpose of testing fatal\nerror handling in libgraal.\n<\/pre>","name":"CrashAtIsFatal","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Pattern for method(s) that will trigger an exception when compiled.\nThis option exists to test handling compilation crashes gracefully. See\nthe MethodFilter option for the pattern syntax. A ':Bailout' suffix\nwill raise a bailout exception and a ':PermanentBailout' suffix will\nraise a permanent bailout exception.\n<\/pre>","name":"CrashAt","prefix":"-XX:","type":"String"},
{"defaultValue":"1.0E-5","description":"<pre>Controls the likelihood of further exploring subtrees with a lot of\ncode during inlining.\n<\/pre>","name":"CutoffCodeSizePenaltyCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"false","description":"<pre>Debug the loop inversion transformation.\n<\/pre>","name":"DebugLoopInversion","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Debug simulation synonyms during simulation-based loop peeling.\n<\/pre>","name":"DebugPeelingSynonyms","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable debug output for stub code generation and snippet preparation.\n<\/pre>","name":"DebugStubsAndSnippets","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"DeoptALot","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Deoptimize OSR compiled code when the OSR entry loop is finished if\nthere is no mature profile available for the rest of the method.\n<\/pre>","name":"DeoptAfterOSR","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"40","name":"DeoptsToDisableOptimisticOptimization","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Enable expensive assertions if normal assertions (i.e. -ea or -esa) are\nenabled.\n<\/pre>","name":"DetailedAsserts","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"3","description":"<pre>Specify the DumpLevel if CompilationFailureAction#Diagnose is used.See\nCompilationFailureAction for details.\nfile:doc-files/CompilationFailureActionHelp.txt\n<\/pre>","name":"DiagnoseDumpLevel","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Ignore calls to System.gc()\n<\/pre>","name":"DisableExplicitGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Disable intercepting exceptions in debug scopes.\n<\/pre>","name":"DisableIntercept","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Analysis: Detect methods that return one of their parameters and\nhardwire the parameter straight to the return.\n<\/pre>","name":"DivertParameterReturningMethod","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"16","name":"DominatorUsageTreeMaxDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Send compiler IR to dump handlers on error.\n<\/pre>","name":"DumpOnError","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Dump a before and after graph if the named phase changes the\ngraph.%nThe argument is substring matched against the simple name of\nthe phase class\n<\/pre>","name":"DumpOnPhaseChange","prefix":"-XX:","type":"String"},
{"defaultValue":"\"graal_dumps\"","description":"<pre>The directory where various Graal dump files are written.\n<\/pre>","name":"DumpPath","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Filter pattern for specifying scopes in which dumping is enabled.\n          \nA filter is a list of comma-separated terms of the form:\n \n  <pattern>[:<level>]\n \nIf <pattern> contains a \"*\" or \"?\" character, it is interpreted as a glob pattern.\nOtherwise, it is interpreted as a substring. If <pattern> is empty, it\nmatches every scope. If :<level> is omitted, it defaults to 1. The term\n~<pattern> is a shorthand for <pattern>:0 to disable a debug facility for a pattern.\n          \nThe default log level is 0 (disabled). Terms with an empty pattern set\nthe default log level to the specified value. The last\nmatching term with a non-empty pattern selects the level specified. If\nno term matches, the log level is the default level. A filter with no\nterms matches every scope with a log level of 1.\n          \nExamples of debug filters:\n--------- \n  (empty string)\n          \n  Matches any scope with level 1.\n--------- \n  :1\n          \n  Matches any scope with level 1.\n--------- \n  *\n          \n  Matches any scope with level 1.\n--------- \n  CodeGen,CodeInstall\n          \n  Matches scopes containing \"CodeGen\" or \"CodeInstall\", both with level 1.\n--------- \n  CodeGen:2,CodeInstall:1\n          \n  Matches scopes containing \"CodeGen\" with level 2, or \"CodeInstall\" with level 1.\n---------\n  Outer:2,Inner:0}\n          \n  Matches scopes containing \"Outer\" with log level 2, or \"Inner\" with log level 0. If the scope\n  name contains both patterns then the log level will be 0. This is useful for silencing subscopes.\n---------\n  :1,Dead:2\n          \n  Matches scopes containing \"Dead\" with level 2, and all other scopes with level 1.\n--------- \n  Dead:0,:1\n          \n  Matches all scopes with level 1, except those containing \"Dead\".   Note that the location of\n  the :1 doesn't matter since it's specifying the default log level so it's the same as\n  specifying :1,Dead:0.\n--------- \n  Code*\n          \n  Matches scopes starting with \"Code\" with level 1.\n--------- \n  Code,~Dead\n          \n  Matches scopes containing \"Code\" but not \"Dead\", with level 1.\n<\/pre>","name":"Dump","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Treat any exceptions during dumping as fatal.\n<\/pre>","name":"DumpingErrorsAreFatal","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Perform Duplications as long as there is any sane improvement.\n<\/pre>","name":"DuplicateALot","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>When enabled, some limited amount of duplication will be performed in\norder compile code containing irreducible loops.\n<\/pre>","name":"DuplicateIrreducibleLoops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.5","description":"<pre>Percentage in node cost graph size for the late duplication budget.\nComputed relative to the methods code size.\n<\/pre>","name":"DuplicationBudgetFactorLate","prefix":"-XX:","type":"Double"},
{"defaultValue":"0.25","description":"<pre>Percentage in node cost graph size for the duplication budget. Computed\nrelative to the methods code size.\n<\/pre>","name":"DuplicationBudgetFactor","prefix":"-XX:","type":"Double"},
{"defaultValue":"64","description":"<pre>Cost/Benefit heuristic for EE simulation-based code duplication: reduce\ncost by a constant factor when comparing with relative benefit.\n<\/pre>","name":"DuplicationCostReductionFactor","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0.66","description":"<pre>Ignore low frequency branches during duplication.\n<\/pre>","name":"DuplicationMinBranchFrequency","prefix":"-XX:","type":"Double"},
{"defaultValue":"true","description":"<pre>Use grouping separators for number printing\n<\/pre>","name":"DynamicCountersPrintGroupSeparator","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Eagerly construct extra snippet info.\n<\/pre>","name":"EagerSnippets","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Try to eliminate array clone operations by handling clone operations in\nearly read elimination.\n<\/pre>","name":"EnterpriseCloneReadElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Run more read eliminations early in the compilation pipeline.\n<\/pre>","name":"EnterpriseEarlyReadElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable EE version of partial loop unrolling that considers more loop\nshapes for unrolling.\n<\/pre>","name":"EnterprisePartialUnroll","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>Maximum ergonomically set heap size (in bytes); zero means use MaxRAM *\nMaxRAMPercentage / 100\n<\/pre>","name":"ErgoHeapSizeLimit","prefix":"-XX:","type":"Long"},
{"defaultValue":"2","name":"EscapeAnalysisIterations","prefix":"-XX:","type":"Integer"},
{"defaultValue":"20","name":"EscapeAnalysisLoopCutoff","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","name":"EscapeAnalyzeOnly","prefix":"-XX:","type":"String"},
{"defaultValue":"800","name":"ExactFullUnrollMaxNodes","prefix":"-XX:","type":"Integer"},
{"defaultValue":"200","name":"ExactPartialUnrollMaxNodes","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Exclude compilations that MethodFilter.match this string from the\nduplication optimization.\n<\/pre>","name":"ExcludeFunctionFromDuplication","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Scan all objects reachable from roots for analysis. By default false.\n<\/pre>","name":"ExhaustiveHeapScan","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Alias for CompilationFailureAction=ExitVM.\n<\/pre>","name":"ExitVMOnException","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"2.0","description":"<pre>The inertia at which the expand-all proximity bonus decreases with the\nnumber of yet unexpanded nodes.\n<\/pre>","name":"ExpandAllProximityBonusInertia","prefix":"-XX:","type":"Double"},
{"defaultValue":"6.0","description":"<pre>The decrease in call graph expansion pressure when there are few call\nnodes left to explore.\n<\/pre>","name":"ExpandAllProximityBonus","prefix":"-XX:","type":"Double"},
{"defaultValue":"550","description":"<pre>The slowness at which the expansion pressure grows with code size; the\nhigher it is, the slower the pressure growth.\n<\/pre>","name":"ExpansionInertiaBaseValue","prefix":"-XX:","type":"Integer"},
{"defaultValue":"14","description":"<pre>The extra slowness at which the expansion pressure grows with the code\nsize, for each extra invoke node.\n<\/pre>","name":"ExpansionInertiaInvokeBonus","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2000","description":"<pre>The max slowness at which the expansion pressure grows with the code\nsize.\n<\/pre>","name":"ExpansionInertiaMax","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>A System.gc() request invokes a concurrent collection\n<\/pre>","name":"ExplicitGCInvokesConcurrent","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable extended asserts which slow down analysis.\n<\/pre>","name":"ExtendedAsserts","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Do not bail out but throw an exception on failed loop explosion.\n<\/pre>","name":"FailedLoopExplosionIsFatal","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"\"","description":"<pre>Internal option used to specify runtime java arguments for\nFallbackExecutor.\n<\/pre>","name":"FallbackExecutorRuntimeJavaArg","prefix":"-XX:","type":"String[]"},
{"defaultValue":"false","description":"<pre>Enable Java Flight Recorder.\n<\/pre>","name":"FlightRecorder","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Force-dump graphs before compilation\n<\/pre>","name":"ForceDumpGraphsBeforeCompilation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Force partial unrolling of loops if at all possible.\n<\/pre>","name":"ForceUnroll","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Perform full unrolling as a Partial Escape Analysis Cleanup\n<\/pre>","name":"FullUnrollAsPEACleanup","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"15","name":"FullUnrollConstantCompareBoost","prefix":"-XX:","type":"Integer"},
{"defaultValue":"60","name":"FullUnrollMaxApplication","prefix":"-XX:","type":"Integer"},
{"defaultValue":"600","name":"FullUnrollMaxIterations","prefix":"-XX:","type":"Integer"},
{"defaultValue":"400","name":"FullUnrollMaxNodes","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"FullUnroll","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"10.0","description":"<pre>Target duration of individual concurrent marking steps in milliseconds.\n<\/pre>","name":"G1ConcMarkStepDurationMillis","prefix":"-XX:","type":"Double"},
{"defaultValue":"4","description":"<pre>The threshold that defines (>=) a hot card.\n<\/pre>","name":"G1ConcRSHotCardLimit","prefix":"-XX:","type":"Long"},
{"defaultValue":"10","description":"<pre>Log base 2 of the length of conc RS hot-card cache.\n<\/pre>","name":"G1ConcRSLogCacheSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>The number of update buffers that are left in the queue by the\nconcurrent processing threads. Will be selected ergonomically by\ndefault.\n<\/pre>","name":"G1ConcRefinementGreenZone","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>Maximum number of enqueued update buffers before mutator threads start\nprocessing new ones instead of enqueueing them. Will be selected\nergonomically by default.\n<\/pre>","name":"G1ConcRefinementRedZone","prefix":"-XX:","type":"Long"},
{"defaultValue":"300","description":"<pre>The last concurrent refinement thread wakes up every specified number\nof milliseconds to do miscellaneous work.\n<\/pre>","name":"G1ConcRefinementServiceIntervalMillis","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>The number of parallel rem set update threads. Will be set\nergonomically by default.\n<\/pre>","name":"G1ConcRefinementThreads","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2","description":"<pre>Each time the rset update queue increases by this amount activate the\nnext refinement thread if available. The actual step size will be\nselected ergonomically by default, with this value used to determine a\nlower bound.\n<\/pre>","name":"G1ConcRefinementThresholdStep","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>Number of enqueued update buffers that will trigger concurrent\nprocessing. Will be selected ergonomically by default.\n<\/pre>","name":"G1ConcRefinementYellowZone","prefix":"-XX:","type":"Long"},
{"defaultValue":"50","description":"<pre>Confidence level for MMU/pause predictions.\n<\/pre>","name":"G1ConfidencePercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"5","description":"<pre>Amount of space, expressed as a percentage of the heap size, that G1 is\nwilling not to collect to avoid expensive GCs.\n<\/pre>","name":"G1HeapWastePercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"8","description":"<pre>The target number of mixed GCs after a marking cycle.\n<\/pre>","name":"G1MixedGCCountTarget","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>Number of milliseconds after a previous GC to wait before triggering a\nperiodic gc. A value of zero disables periodically enforced gc cycles.\n<\/pre>","name":"G1PeriodicGCInterval","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","description":"<pre>Determines the kind of periodic GC. Set to true to have G1 perform a\nconcurrent GC as periodic GC, otherwise use a STW Full GC.\n<\/pre>","name":"G1PeriodicGCInvokesConcurrent","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.0","description":"<pre>Maximum recent system wide load as returned by the 1m value of\ngetloadavg() at which G1 triggers a periodic GC. A load above this\nvalue cancels a given periodic GC. A value of zero disables this check.\n<\/pre>","name":"G1PeriodicGCSystemLoadThreshold","prefix":"-XX:","type":"Double"},
{"defaultValue":"0","description":"<pre>Max number of regions for which we keep bitmaps. Will be set\nergonomically by default\n<\/pre>","name":"G1RSetRegionEntries","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>Max number of entries per region in a sparse table. Will be set\nergonomically by default.\n<\/pre>","name":"G1RSetSparseRegionEntries","prefix":"-XX:","type":"Long"},
{"defaultValue":"10","description":"<pre>A target percentage of time that is allowed to be spend on process RS\nupdate buffers during the collection pause.\n<\/pre>","name":"G1RSetUpdatingPauseTimePercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"1000","description":"<pre>The number of discovered reference objects to process before draining\nconcurrent marking work queues.\n<\/pre>","name":"G1RefProcDrainInterval","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10","description":"<pre>It determines the minimum reserve we should have in the heap to\nminimize the probability of promotion failure.\n<\/pre>","name":"G1ReservePercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"60","description":"<pre>Before enqueueing them, each mutator thread tries to do some filtering\non the SATB buffers it generates. If post-filtering the percentage of\nretained entries is over this threshold the buffer will be enqueued for\nprocessing. A value of 0 specifies that mutator threads should not do\nsuch filtering.\n<\/pre>","name":"G1SATBBufferEnqueueingThresholdPercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"1024","description":"<pre>Number of entries in an SATB log buffer.\n<\/pre>","name":"G1SATBBufferSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"256","description":"<pre>Size of an update buffer.\n<\/pre>","name":"G1UpdateBufferSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","description":"<pre>Select green, yellow and red zones adaptively to meet the the pause\nrequirements.\n<\/pre>","name":"G1UseAdaptiveConcRefinement","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Adaptively adjust the initiating heap occupancy from the initial value\nof InitiatingHeapOccupancyPercent. The policy attempts to start marking\nin time based on application behavior.\n<\/pre>","name":"G1UseAdaptiveIHOP","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verifies the consistency of the marking bitmaps\n<\/pre>","name":"G1VerifyBitmaps","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify the code root lists attached to each heap region.\n<\/pre>","name":"G1VerifyHeapRegionCodeRoots","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>If true, perform verification of each heap region's remembered set when\nverifying the heap during a full GC.\n<\/pre>","name":"G1VerifyRSetsDuringFullGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"-1","description":"<pre>Start tracing compiled GC barriers after N garbage collections\n(disabled if N <= 0).\n<\/pre>","name":"GCDebugStartCycle","prefix":"-XX:","type":"Integer"},
{"defaultValue":"64","description":"<pre>Number of entries we will try to leave on the stack during parallel gc\n<\/pre>","name":"GCDrainStackTargetSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"201","description":"<pre>Time slice for MMU specification\n<\/pre>","name":"GCPauseIntervalMillis","prefix":"-XX:","type":"Long"},
{"defaultValue":"12","description":"<pre>Adaptive size policy application time to GC time ratio\n<\/pre>","name":"GCTimeRatio","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","name":"GenLoopSafepoints","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Generate position independent code\n<\/pre>","name":"GeneratePIC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Generate debuginfo for runtime-compiled code.\n<\/pre>","name":"GenerateRuntimeDebugInfo","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Turn on the benchmark counters, and displays the results on VM shutdown\n<\/pre>","name":"GenericDynamicCounters","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use Graal arithmetic stubs instead of HotSpot stubs where possible\n<\/pre>","name":"GraalArithmeticStubs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>A filter applied to a method the VM has selected for compilation by\nGraal. A method not matching the filter is redirected to a lower tier\ncompiler. The filter format is the same as for the MethodFilter option.\n<\/pre>","name":"GraalCompileOnly","prefix":"-XX:","type":"String"},
{"defaultValue":"70","description":"<pre>Graal graph compression is performed when percent of live nodes falls\nbelow this value\n<\/pre>","name":"GraphCompressionThreshold","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"GuardPriorities","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"44040192","description":"<pre>Size of heap (bytes) per GC thread used in calculating the number of GC\nthreads\n<\/pre>","name":"HeapSizePerGCThread","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","description":"<pre>Failed verification of the heap (if enabled) causes termination.\n<\/pre>","name":"HeapVerificationFailureIsFatal","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable EE partial unrolling in high tier.\n<\/pre>","name":"HighTierPartialUnrolling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Testing only option that forces deopts for exception throws\n<\/pre>","name":"HotSpotDeoptExplicitExceptions","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Testing only option that forces deopts for exception throws\n<\/pre>","name":"HotSpotPostOnExceptions","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print inlining optimizations\n<\/pre>","name":"HotSpotPrintInlining","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable hybrid context for static methods, i.e. uses invocation site as\ncontext for static methods.\n<\/pre>","name":"HybridStaticContext","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Ignore duplications with a bad benefit cost relation.\n<\/pre>","name":"IgnoreBadDuplications","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"\"","description":"<pre>Override the default suppression of specified roots. See: Reports.md.\n<\/pre>","name":"ImageObjectTreeExpandRoots","prefix":"-XX:","type":"String"},
{"defaultValue":"\"\"","description":"<pre>Override the default suppression of specified types. See: Reports.md.\n<\/pre>","name":"ImageObjectTreeExpandTypes","prefix":"-XX:","type":"String"},
{"defaultValue":"\"\"","description":"<pre>Suppress the expansion of specified roots. See: Reports.md.\n<\/pre>","name":"ImageObjectTreeSuppressRoots","prefix":"-XX:","type":"String"},
{"defaultValue":"\"\"","description":"<pre>Suppress the expansion of specified types. See: Reports.md.\n<\/pre>","name":"ImageObjectTreeSuppressTypes","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Try to avoid emitting code where patching is required\n<\/pre>","name":"ImmutableCode","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Specifies if initialization timing is enabled.\n<\/pre>","name":"InitTimer","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>Initial heap size (in bytes); zero means use ergonomics\n<\/pre>","name":"InitialHeapSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"1.5625","description":"<pre>Percentage of real memory used for initial heap size\n<\/pre>","name":"InitialRAMPercentage","prefix":"-XX:","type":"Double"},
{"defaultValue":"45","description":"<pre>The percent occupancy (IHOP) of the current old generation capacity\nabove which a concurrent mark cycle will be initiated. Its value may\nchange over time if adaptive IHOP is enabled, otherwise the value\nremains constant. In the latter case a value of 0 will result as\nfrequent as possible concurrent marking cycles. A value of 100 disables\nconcurrent marking. Fragmentation waste in the old generation is not\nconsidered free space in this calculation.\n<\/pre>","name":"InitiatingHeapOccupancyPercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"1.0","description":"<pre>The bonus applied to call nodes that can be fully inlined.\n<\/pre>","name":"InlineAllBonus","prefix":"-XX:","type":"Double"},
{"defaultValue":"10","description":"<pre>Maximum depth when inlining during bytecode parsing.\n<\/pre>","name":"InlineDuringParsingMaxDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Inlines trivial methods during bytecode parsing.\n<\/pre>","name":"InlineDuringParsing","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"InlineEverything","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Inlines intrinsic methods during bytecode parsing.\n<\/pre>","name":"InlineIntrinsicsDuringParsing","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Inline calls with megamorphic type profile (i.e., not all types could\nbe recorded).\n<\/pre>","name":"InlineMegamorphicCalls","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Inline calls with monomorphic type profile.\n<\/pre>","name":"InlineMonomorphicCalls","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Inlines partial intrinsic exits during bytecode parsing when possible.\nA partial intrinsic exit is a call within an intrinsic to the method\nbeing intrinsified and denotes semantics of the original method that\nthe intrinsic does not support.\n<\/pre>","name":"InlinePartialIntrinsicExitDuringParsing","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Inline calls with polymorphic type profile.\n<\/pre>","name":"InlinePolymorphicCalls","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"InlineVTableStubs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable inlining\n<\/pre>","name":"Inline","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"20000","description":"<pre>Controls the maximum number of compiler nodes that can be inlined into\nthe compiled method.\n<\/pre>","name":"InlinedCompilerNodeLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0.02","description":"<pre>The coefficient used to compute the inlining threshold; the higher, the\nmore to inline.\n<\/pre>","name":"InliningCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"1000","description":"<pre>Maximum inlining depth during partial evaluation before reporting an\ninfinite recursion\n<\/pre>","name":"InliningDepthError","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Do not unroll the main loop, only create pre-main-post.\n<\/pre>","name":"InsertPreMainPostOnly","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Inspect analysis graphs.\n<\/pre>","name":"InspectGraphs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"inspect\"","description":"<pre>Path to the contents of the Inspect web server.\n<\/pre>","name":"InspectServerContentPath","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Install segfault handler that prints register contents and full Java\nstacktrace. Default: enabled for an executable, disabled for a shared\nlibrary.\n<\/pre>","name":"InstallSegfaultHandler","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Intercept also bailout exceptions\n<\/pre>","name":"InterceptBailout","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use compiler intrinsifications.\n<\/pre>","name":"Intrinsify","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable dynamic move profiling per method.\n<\/pre>","name":"LIRDynMoveProfileMethod","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable constant load optimization.\n<\/pre>","name":"LIROptConstantLoadOptimization","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LIROptControlFlowOptimizer","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LIROptEdgeMoveOptimizer","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable spill move elimination.\n<\/pre>","name":"LIROptLSRAEliminateSpillMoves","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable spill position optimization\n<\/pre>","name":"LIROptLSRAOptimizeSpillPosition","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use linear scan stack slot allocation.\n<\/pre>","name":"LIROptLSStackSlotAllocator","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LIROptNullCheckOptimizer","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LIROptRedundantMoveElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LIROptStackMoveOptimizer","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable LIR level optimiztations.\n<\/pre>","name":"LIROptimization","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enables profiling of methods.\n<\/pre>","name":"LIRProfileMethods","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enables profiling of move types on LIR level. Move types are for\nexample stores (register to stack), constant loads (constant to\nregister) or copies (register to register).\n<\/pre>","name":"LIRProfileMoves","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>LSRA optimization: Only split but do not reassign\n<\/pre>","name":"LSRAOptSplitOnly","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable LSRA optimization\n<\/pre>","name":"LSRAOptimization","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.005","description":"<pre>Reduces the likelihood of exploring call graphs that have a lot of\nchildren below the root.\n<\/pre>","name":"LargeChildrenCountPenaltyCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"1000","description":"<pre>Milliseconds to delay initialization of the libgraal JMX interface.\nSpecify a negative value to disable the interface altogether.\n<\/pre>","name":"LibGraalManagementDelay","prefix":"-XX:","type":"Integer"},
{"defaultValue":"5.0","name":"LimitInlinedInvokes","prefix":"-XX:","type":"Double"},
{"defaultValue":"false","description":"<pre>Enable a limit for the number of objects recorded for each type of a\ntype state before disabling heap sensitivity for that type. The\nanalysis must be heap sensitive.\n<\/pre>","name":"LimitObjectArrayLength","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Lists on the console at VM shutdown the metric names available to the\nTimers, Counters and MemUseTrackers options. Note that this only lists\nthe metrics that were initialized during the VM execution and so will\nnot include metrics for compiler code that is not executed.\n<\/pre>","name":"ListMetrics","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Use a VM runtime call to load and clear the exception object from the\nthread at the start of a compiled exception handler.\n<\/pre>","name":"LoadExceptionObjectInVM","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>File to which logging is sent. A %p in the name will be replaced with a\nstring identifying the process, usually the process id and %t will be\nreplaced by System.currentTimeMillis(). If the current runtime is in an\nisolate, then %i will be replaced by '<isolate id>' otherwise %i is\nremoved. An %I is the same as %i except that the replacement is\n'<isolate id>@<isolate address>'. Using %o as filename sends logging to\nSystem.out whereas %e sends logging to System.err.\n<\/pre>","name":"LogFile","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Enable more verbose log output when available\n<\/pre>","name":"LogVerbose","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Pattern for specifying scopes in which logging is enabled. See the Dump\noption for the pattern syntax.\n<\/pre>","name":"Log","prefix":"-XX:","type":"String"},
{"defaultValue":"16","description":"<pre>Alignment in bytes for loop header blocks.\n<\/pre>","name":"LoopHeaderAlignment","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Convert loops into their zero trip form.\n<\/pre>","name":"LoopInversion","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"3","name":"LoopMaxUnswitch","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"LoopPeeling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LoopPredicationMainPath","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"LoopPredication","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"10.0","name":"LoopUnswitchFrequencyBoost","prefix":"-XX:","type":"Double"},
{"defaultValue":"500","name":"LoopUnswitchMaxIncrease","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10","name":"LoopUnswitchTrivial","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"LoopUnswitch","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"536870912","description":"<pre>Maximum size of marking stack\n<\/pre>","name":"MarkStackSizeMax","prefix":"-XX:","type":"Long"},
{"defaultValue":"4194304","description":"<pre>Size of marking stack\n<\/pre>","name":"MarkStackSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","description":"<pre>Allow backend to match complex expressions.\n<\/pre>","name":"MatchExpressions","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>The maximum length of the methods context chains.\n<\/pre>","name":"MaxCallingContextDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>The maximum number of contexts to record for a method. It only affects\nthe analysis when the max and min calling context depth are different.\n<\/pre>","name":"MaxCallingContextWidth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2","description":"<pre>The maximum number of compilation failures to handle with the action\nspecified by CompilationFailureAction before changing to a less verbose\naction. This does not apply to the ExitVM action.\n<\/pre>","name":"MaxCompilationProblemsPerAction","prefix":"-XX:","type":"Integer"},
{"defaultValue":"100","description":"<pre>The maximum number of constant objects recorded for each type before\nmerging the constants into one unique constant object per type. The\nanalysis must be heap sensitive. It has a minimum value of 1.\n<\/pre>","name":"MaxConstantObjectsPerType","prefix":"-XX:","type":"Integer"},
{"defaultValue":"64","description":"<pre>Upper bound on the number of cpu locals per counter. It has to be a\npower of 2.\n<\/pre>","name":"MaxCpuLocalsPerCounter","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>Maximum total size of NIO direct-buffer allocations\n<\/pre>","name":"MaxDirectMemorySize","prefix":"-XX:","type":"Long"},
{"defaultValue":"2.0","description":"<pre>How much duplication can happen because of irreducible loops before\nbailing out.\n<\/pre>","name":"MaxDuplicationFactor","prefix":"-XX:","type":"Double"},
{"defaultValue":"200","description":"<pre>Adaptive size policy maximum GC pause time goal in millisecond, or the\nmaximum GC time per MMU time slice\n<\/pre>","name":"MaxGCPauseMillis","prefix":"-XX:","type":"Long"},
{"defaultValue":"100000","description":"<pre>Maximum node cost graph size for duplication. If a graph is bigger\nduplication will stop.\n<\/pre>","name":"MaxGraphSizeNodeCost","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>The maximum length of the context used to model a heap object in\naddition to the allocation site; used only when ContextSensitiveHeap is\nenabled.\n<\/pre>","name":"MaxHeapContextDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>The maximum number of contexts to record for a heap object. It only\naffects the analysis when the max and min calling context depth are\ndifferent.\n<\/pre>","name":"MaxHeapContextWidth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>The maximum heap size at run-time, in bytes.\n<\/pre>","name":"MaxHeapSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"1024","description":"<pre>The maximum number of lines in the stack trace for Java exceptions (0\nmeans all)\n<\/pre>","name":"MaxJavaStackTraceDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2.0","description":"<pre>Abstract measure of the cost of branch misprediction. Higher values\nmake generation of conditional moves more likely.\n<\/pre>","name":"MaxMispredictionCostIncreaseFactor","prefix":"-XX:","type":"Double"},
{"defaultValue":"0","description":"<pre>The maximum size of the young generation at run-time, in bytes\n<\/pre>","name":"MaxNewSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"100","description":"<pre>The maximum number of objects recorded for each type of a type state\nbefore disabling heap sensitivity for that type. The analysis must be\nheap sensitive. It has a minimum value of 1.\n<\/pre>","name":"MaxObjectSetSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"3","description":"<pre>The maximum number of dispatches in guarded polymorphic inlining.\n<\/pre>","name":"MaxPolymorphicDispatches","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10","description":"<pre>Max number of precise inlining peeling iterations.\n<\/pre>","name":"MaxPriorityInliningPeelingIterations","prefix":"-XX:","type":"Integer"},
{"defaultValue":"25.0","description":"<pre>Maximum percentage of real memory used for maximum heap size\n<\/pre>","name":"MaxRAMPercentage","prefix":"-XX:","type":"Double"},
{"defaultValue":"137438953472","description":"<pre>Real memory size (in bytes) used to set maximum heap size\n<\/pre>","name":"MaxRAM","prefix":"-XX:","type":"Long"},
{"defaultValue":"2","description":"<pre>Maximum simulation-duplication iterations of the duplication\noptimization per invocation.\n<\/pre>","name":"MaxSimulationIterations","prefix":"-XX:","type":"Integer"},
{"defaultValue":"32","name":"MaxSplitsPerNode","prefix":"-XX:","type":"Integer"},
{"defaultValue":"50","name":"MaxTemplatesPerSnippet","prefix":"-XX:","type":"Integer"},
{"defaultValue":"15","description":"<pre>Maximum value for tenuring threshold\n<\/pre>","name":"MaxTenuringThreshold","prefix":"-XX:","type":"Long"},
{"defaultValue":"4","description":"<pre>Maximum number of unrolled alignment instructions\n<\/pre>","name":"MaxVectorAlignmentUnroll","prefix":"-XX:","type":"Integer"},
{"defaultValue":"16","description":"<pre>Maximum length of linear-code vector operations\n<\/pre>","name":"MaxVectorUnroll","prefix":"-XX:","type":"Integer"},
{"defaultValue":"20000","description":"<pre>Maximum desired size of the compiler graph in nodes.\n<\/pre>","name":"MaximumDesiredSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"128","description":"<pre>The maximum length of an array that will be escape analyzed.\n<\/pre>","name":"MaximumEscapeAnalysisArrayLength","prefix":"-XX:","type":"Integer"},
{"defaultValue":"80","description":"<pre>The maximum heap size as percent of physical memory\n<\/pre>","name":"MaximumHeapSizePercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"300","description":"<pre>Inlining is explored up to this number of nodes in the graph for each\ncall site.\n<\/pre>","name":"MaximumInliningSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10000","description":"<pre>Max number of loop explosions per method.\n<\/pre>","name":"MaximumLoopExplosionCount","prefix":"-XX:","type":"Integer"},
{"defaultValue":"5","description":"<pre>Maximum level of recursive inlining.\n<\/pre>","name":"MaximumRecursiveInlining","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2","description":"<pre>PullThroughPhiOptimization: Maximum number of algorithm iterations per\noptimization invocation.\n<\/pre>","name":"MaximumTransitiveEnabledPullFactor","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10","description":"<pre>The maximum size of the young generation as a percentage of the maximum\nheap size\n<\/pre>","name":"MaximumYoungGenerationSizePercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0.33","description":"<pre>Minimum probability for methods to be inlined for megamorphic type\nprofiles.\n<\/pre>","name":"MegamorphicInliningMinMethodProbability","prefix":"-XX:","type":"Double"},
{"defaultValue":"null","description":"<pre>Comma separated names of memory usage trackers that are enabled\nirrespective of the value for TrackMemUse option. An empty value\nenables all memory usage trackers unconditionally.\n<\/pre>","name":"MemUseTrackers","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Only check MethodFilter against the root method in the context if true,\notherwise check all methods\n<\/pre>","name":"MethodFilterRootOnly","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Pattern for matching methods. The syntax for a pattern is:\n          \n  SourcePatterns = SourcePattern [\",\" SourcePatterns] .\n  SourcePattern = [ \"~\" ] [ Class \".\" ] method [ \"(\" [ Parameter { \";\" Parameter } ] \")\" ] .\n  Parameter = Class | \"int\" | \"long\" | \"float\" | \"double\" | \"short\" | \"char\" | \"boolean\" .\n  Class = { package \".\" } class .\n          \nGlob pattern matching (*, ?) is allowed in all parts of the source pattern.\nThe \"~\" prefix negates the pattern.\n          \nPositive patterns are joined by an \"or\" operator: \"A,B\" matches anything\nmatched by \"A\" or \"B\". Negative patterns are joined by \"and not\": \"~A,~B\"\nmatches anything not matched by \"A\" and not matched by \"B\". \"A,~B,~C,D\"\nmatches anything matched by \"A\" or \"D\" and not matched by \"B\" and not\nmatched by \"C\".\n          \nA set of patterns containing negative patterns but no positive ones contains\nan implicit positive \"*\" pattern: \"~A,~B\" is equivalent to \"*,~A,~B\".\n          \nExamples of method filters:\n---------\n  *\n          \n  Matches all methods in all classes.\n---------\n  canonical(CanonicalizerTool;LogicNode;LogicNode)\n          \n  Matches all methods named \"canonical\", with the first parameter of type\n  \"CanonicalizerTool\", and the second and third parameters of type\n  \"LogicNode\".\n  The packages of the parameter types are irrelevant.\n---------\n  arraycopy(Object;;;;)\n          \n  Matches all methods named \"arraycopy\", with the first parameter\n  of type \"Object\", and four more parameters of any type. The\n  packages of the parameter types are irrelevant.\n---------\n  org.graalvm.compiler.nodes.PhiNode.*\n          \n  Matches all methods in the class \"org.graalvm.compiler.nodes.PhiNode\".\n---------\n  org.graalvm.compiler.nodes.*.canonical\n          \n  Matches all methods named \"canonical\" in classes in the package\n  \"org.graalvm.compiler.nodes\".\n---------\n  arraycopy,toString\n          \n  Matches all methods named \"arraycopy\" or \"toString\", meaning that ',' acts\n  as an \"or\" operator.\n---------\n  java.util.*.*.,~java.util.*Array*.*\n  java.util.*.*.,~*Array*.*\n          \n  These patterns are equivalent and match all methods in the package\n  \"java.util\" except for classes that have \"Array\" in their name.\n---------\n  ~java.util.*.*\n          \n  Matches all methods in all classes in all packages except for anything in\n  the \"java.util\" package.\n<\/pre>","name":"MethodFilter","prefix":"-XX:","type":"String"},
{"defaultValue":"5000","description":"<pre>Per-compilation method inlining exploration limit before giving up (use\n0 to disable)\n<\/pre>","name":"MethodInlineBailoutLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>File to which metrics are dumped per compilation.\nA CSV format is used if the file ends with .csv otherwise a more\nhuman readable format is used. The fields in the CSV format are:\n           compilable - method being compiled\n  compilable_identity - identity hash code of compilable\n       compilation_nr - where this compilation lies in the ordered\n                        sequence of all compilations identified by\n                        compilable_identity\n       compilation_id - runtime issued identifier for the compilation\n          metric_name - name of metric\n         metric_value - value of metric\n<\/pre>","name":"MetricsFile","prefix":"-XX:","type":"String"},
{"defaultValue":"true","description":"<pre>Enable EE partial unrolling in mid tier.\n<\/pre>","name":"MidTierPartialUnrolling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.66","description":"<pre>PullThroughPhiOptimization: Ignore low frequency branches during\nduplication.\n<\/pre>","name":"MinBlockFrequencyPull","prefix":"-XX:","type":"Double"},
{"defaultValue":"0","description":"<pre>The minimum length of the methods context chains.\n<\/pre>","name":"MinCallingContextDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>The minimum length of the context used to model a heap object in\naddition to the allocation site; used only when ContextSensitiveHeap is\nenabled.\n<\/pre>","name":"MinHeapContextDepth","prefix":"-XX:","type":"Integer"},
{"defaultValue":"172032","description":"<pre>The minimum change in heap space due to GC (in bytes).\n<\/pre>","name":"MinHeapDeltaBytes","prefix":"-XX:","type":"Long"},
{"defaultValue":"40","description":"<pre>The minimum percentage of heap free after GC to avoid expansion.\n<\/pre>","name":"MinHeapFreeRatio","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>The minimum heap size at run-time, in bytes.\n<\/pre>","name":"MinHeapSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"0.1","description":"<pre>The minimum probability for using a dispatch in guarded polymorphic\ninlining.\n<\/pre>","name":"MinPolymorphicDispatchProbability","prefix":"-XX:","type":"Double"},
{"defaultValue":"50.0","description":"<pre>Minimum percentage of real memory used for maximum heap size on systems\nwith small physical memory size\n<\/pre>","name":"MinRAMPercentage","prefix":"-XX:","type":"Double"},
{"defaultValue":"2048","description":"<pre>Minimum allowed TLAB size (in bytes)\n<\/pre>","name":"MinTLABSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"2048","description":"<pre>If applicable, use bulk zeroing instructions when the zeroing size in\nbytes exceeds this threshold.\n<\/pre>","name":"MinimalBulkZeroingSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Try to reduce duplication code size to the minimal amount of code.\n<\/pre>","name":"MinimalRegions","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.35","name":"MinimumPeelFrequency","prefix":"-XX:","type":"Float"},
{"defaultValue":"2","description":"<pre>Cost/Benefit heuristic for EE unrolling: If a loop has multiple exits,\ncost is increased by this value for every sinking loop exit.\n<\/pre>","name":"MultiExitCostFactorSink","prefix":"-XX:","type":"Integer"},
{"defaultValue":"32","description":"<pre>Cost/Benefit heuristic for EE unrolling: If a loop has multiple exits,\ncost is increased by this value for every none-sinking loop exit.\n<\/pre>","name":"MultiExitCostFactor","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>Run level for NoDeadCodeVerifyHandler (0 = off, 1 = info, 2 = verbose,\n3 = fatal)\n<\/pre>","name":"NDCV","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2","description":"<pre>Ratio of old/new generation sizes\n<\/pre>","name":"NewRatio","prefix":"-XX:","type":"Long"},
{"defaultValue":"1048576","description":"<pre>Initial new generation size (in bytes)\n<\/pre>","name":"NewSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"false","description":"<pre>Counts the number of instances of each node class.\n<\/pre>","name":"NodeCounters","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"20","description":"<pre>Number of contiguous identical compiler thread stack traces allowed\nbefore the VM exits on the basis of a stuck compilation.\n<\/pre>","name":"NonFatalIdenticalCompilationSnapshots","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Comma separated list of candidate GNU objdump executables. If not\nspecified, disassembling via GNU objdump is disabled. Otherwise, the\nfirst existing executable in the list is used.\n<\/pre>","name":"ObjdumpExecutables","prefix":"-XX:","type":"String"},
{"defaultValue":"1024","description":"<pre>Size of old gen promotion LAB's (in HeapWords)\n<\/pre>","name":"OldPLABSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"5242880","description":"<pre>Initial tenured generation size (in bytes)\n<\/pre>","name":"OldSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"false","name":"OmitHotExceptionStacktrace","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptAssumptions","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptBulkAllocation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptCompressedFrameStateValues","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Optimize simple if branches with conditional moves\n<\/pre>","name":"OptConditionalMoves","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptConvertDeoptsToGuards","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptDeDuplication","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptDeoptimizationGrouping","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptDevirtualizeInvokesOptimistically","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptDuplication","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptEarlyReadElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptEliminateGuards","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptExactArithmetic","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptFloatingReads","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptGuardRangeGrouping","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptImplicitNullChecks","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"OptLateDuplication","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptLockElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Inject stamps on induction variables.\n<\/pre>","name":"OptLoopPhiStamps","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptPullThroughPhi","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptReadElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptScheduleOutOfLoops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptSpeculativeGuardMovement","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Dump graphs to help debug operation\n<\/pre>","name":"OptStringConcatDump","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Optimize StringBuilder construction\n<\/pre>","name":"OptStringConcat","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Eliminate redundant write barriers.\n<\/pre>","name":"OptWriteBarrierElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"OptimisticAliasingAnalysis","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable access node optimizations for loops\n<\/pre>","name":"OptimizeLoopAccesses","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Dump information for Profile Guided Optimizations (true or file name)\n<\/pre>","name":"PGOInstrument","prefix":"-XX:","type":"String"},
{"defaultValue":"75","description":"<pre>Percentage (0-100) used to weight the current sample when computing\nexponentially decaying average for ResizePLAB\n<\/pre>","name":"PLABWeight","prefix":"-XX:","type":"Integer"},
{"defaultValue":"50","description":"<pre>Scan a subset of object array and push remainder, if array is bigger\nthan this\n<\/pre>","name":"ParGCArrayScanChunk","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10","description":"<pre>Wasted fraction of parallel allocation buffer\n<\/pre>","name":"ParallelGCBufferWastePct","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>Number of parallel threads parallel gc will use\n<\/pre>","name":"ParallelGCThreads","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Enable balancing of reference processing queues\n<\/pre>","name":"ParallelRefProcBalancingEnabled","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable parallel reference processing whenever possible\n<\/pre>","name":"ParallelRefProcEnabled","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"PartialEscapeAnalysis","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable partial redundancy elimination\n<\/pre>","name":"PartialRedundancyElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"2","description":"<pre>Cost/Benefit heuristic for EE unrolling in high tier: reduce cost by a\nconstant factor when comparing with relative benefit.\n<\/pre>","name":"PartialUnrollCostReductionFactorHighTier","prefix":"-XX:","type":"Integer"},
{"defaultValue":"8","description":"<pre>Cost/Benefit heuristic for EE unrolling in mid tier: reduce cost by a\nconstant factor when comparing with relative benefit.\n<\/pre>","name":"PartialUnrollCostReductionFactorMidTier","prefix":"-XX:","type":"Integer"},
{"defaultValue":"4","description":"<pre>Maximum number of iterations to unroll for a high tier main loop.\n<\/pre>","name":"PartialUnrollMaxIterationsHighTier","prefix":"-XX:","type":"Integer"},
{"defaultValue":"16","description":"<pre>Maximum number of iterations to unroll for a mid tier main loop.\n<\/pre>","name":"PartialUnrollMaxIterationsMidTier","prefix":"-XX:","type":"Integer"},
{"defaultValue":"256","description":"<pre>Maximum node cost size of a loop to be considered for high tier\nunrolling.\n<\/pre>","name":"PartialUnrollMaxSizeHighTier","prefix":"-XX:","type":"Integer"},
{"defaultValue":"256","description":"<pre>Maximum node cost size of a loop to be considered for mid tier tier\nunrolling.\n<\/pre>","name":"PartialUnrollMaxSizeMidTier","prefix":"-XX:","type":"Integer"},
{"defaultValue":"2","description":"<pre>Minimal loop frequency to consider a loop for partial unrolling\n<\/pre>","name":"PartialUnrollMinFrequency","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"PartialUnroll","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"10","description":"<pre>The limit on the number of paths at control-flow merges. Decreasing\nthis value reduces the number of paths, but also shortens them.\n<\/pre>","name":"PathProfileCutThreshold","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Dump information for path profile (null or file name). If set to null,\nthen dumping is disabled.\n<\/pre>","name":"PathProfileDumpFile","prefix":"-XX:","type":"String"},
{"defaultValue":"500","description":"<pre>Maximum acceptable number of paths coming from the inbound of a merge\nif both of them are frequent.\n<\/pre>","name":"PathProfileFrequentThreshold","prefix":"-XX:","type":"Long"},
{"defaultValue":"0.1","description":"<pre>If some block's relative frequency drops below this number times the\nmaximum relative frequency in the graph, then the block is considered\ninfrequent.\n<\/pre>","name":"PathProfileGlobalLowFrequencyRatio","prefix":"-XX:","type":"Double"},
{"defaultValue":"10.0","description":"<pre>If the ratio of the merge's frequency with its inbound's frequency is\ngreater than this threshold, then the inbound is considered infrequent.\n<\/pre>","name":"PathProfileLocalLowFrequencyRatio","prefix":"-XX:","type":"Double"},
{"defaultValue":"4000000","description":"<pre>Maximum number of counters to use in path profiling for all\ninstrumented methods.\n<\/pre>","name":"PathProfileMaxTotalCounters","prefix":"-XX:","type":"Integer"},
{"defaultValue":"None","description":"<pre>Enable or disable the path-profiling algorithm. If it enables it, it\nalso allows to select which mode to execute.\n<\/pre>","name":"PathProfilePolicy","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Controls whether the path-regeneration algorithm is executed.\n<\/pre>","name":"PathProfileRegenerate","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"PeelALot","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"120","name":"PeelFoldFactor","prefix":"-XX:","type":"Integer"},
{"defaultValue":"4.0","description":"<pre>Minimal loop frequency necessary to consider peeling.\n<\/pre>","name":"PeelingConsideredMinFrequency","prefix":"-XX:","type":"Double"},
{"defaultValue":"true","description":"<pre>Increase the cost of duplicating control flow splits inside loops if\nthey are not foldable.The generally tend to complicate control flow and\ngenerate worse code in the backend.\n<\/pre>","name":"PenalizeComplexLoopControlFlow","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"50","description":"<pre>Percentage of total collection time that should be spent on young\ngeneration collections.\n<\/pre>","name":"PercentTimeInIncrementalCollection","prefix":"-XX:","type":"Integer"},
{"defaultValue":"32768","description":"<pre>Size of performance data memory region. Will be rounded up to a\nmultiple of the native os page size.\n<\/pre>","name":"PerfDataMemorySize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"200","description":"<pre>Jvmstat instrumentation sampling interval (in milliseconds)\n<\/pre>","name":"PerfDataSamplingInterval","prefix":"-XX:","type":"Integer"},
{"defaultValue":"1024","description":"<pre>Maximum PerfStringConstant string length before truncation\n<\/pre>","name":"PerfMaxStringConstLength","prefix":"-XX:","type":"Integer"},
{"defaultValue":"1073741824","description":"<pre>Per-thread chunk size for parallel memory pre-touch.\n<\/pre>","name":"PreTouchParallelChunkSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","description":"<pre>Calculate the container CPU availability based on the value of quotas\n(if set), when true. Otherwise, use the CPU shares value, provided it\nis less than quota.\n<\/pre>","name":"PreferContainerQuotaForCPUCount","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"-1","description":"<pre>How far ahead to prefetch destination area (<= 0 means off)\n<\/pre>","name":"PrefetchCopyIntervalInBytes","prefix":"-XX:","type":"Long"},
{"defaultValue":"-1","description":"<pre>How far ahead to prefetch scan area (<= 0 means off)\n<\/pre>","name":"PrefetchScanIntervalInBytes","prefix":"-XX:","type":"Long"},
{"defaultValue":"false","description":"<pre>Print analysis call tree, a breadth-first tree reduction of the call\ngraph.\n<\/pre>","name":"PrintAnalysisCallTree","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print analysis results statistics.\n<\/pre>","name":"PrintAnalysisStatistics","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable dumping LIR, register allocation and code generation info to the\nC1Visualizer.\n<\/pre>","name":"PrintBackendCFG","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable dumping CFG built during initial BciBlockMapping\n<\/pre>","name":"PrintBlockMapping","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable dumping to the C1Visualizer. Enabling this option implies\nPrintBackendCFG.\n<\/pre>","name":"PrintCFG","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>Choose format used when dumping canonical text for graphs: 0 gives a\nscheduled graph (better for spotting changes involving the schedule)\nwhile 1 gives a CFG containing expressions rooted at fixed nodes\n(better for spotting small structure differences)\n<\/pre>","name":"PrintCanonicalGraphStringFlavor","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Enable dumping canonical text from for graphs.\n<\/pre>","name":"PrintCanonicalGraphStrings","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print an informational line to the console for each completed\ncompilation.\n<\/pre>","name":"PrintCompilation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Prints VM configuration available via JVMCI.\n<\/pre>","name":"PrintConfig","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Print detailed information for each allocation site\n<\/pre>","name":"PrintDetailedAllocationProfiling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Print extra help, if available, based on comma-separated option names.\nPass * to show all options that contain extra help.\n<\/pre>","name":"PrintFlagsWithExtraHelp","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Show available options based on comma-separated option-types (allowed\ncategories: User, Expert, Debug).\n<\/pre>","name":"PrintFlags","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Print summary GC information after application main method returns.\n<\/pre>","name":"PrintGCSummary","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print a time stamp at each collection, if +PrintGC or +VerboseGC.\n<\/pre>","name":"PrintGCTimeStamps","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print the time for each of the phases of each collection, if\n+VerboseGC.\n<\/pre>","name":"PrintGCTimes","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print summary GC information after each collection\n<\/pre>","name":"PrintGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Setting to true sets PrintGraph=file, setting to false sets\nPrintGraph=network\n<\/pre>","name":"PrintGraphFile","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"127.0.0.1\"","description":"<pre>Host part of the address to which graphs are dumped.\n<\/pre>","name":"PrintGraphHost","prefix":"-XX:","type":"String"},
{"defaultValue":"4445","description":"<pre>Port part of the address to which graphs are dumped in binary format.\n<\/pre>","name":"PrintGraphPort","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Schedule graphs as they are dumped.\n<\/pre>","name":"PrintGraphWithSchedule","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"File","description":"<pre>Where IdealGraphVisualizer graph dumps triggered by Dump or DumpOnError\nshould be written.\nThe accepted values are:\n      File - Dump IGV graphs to the local file system (see DumpPath).\n   Network - Dump IGV graphs to the network destination specified by PrintGraphHost and PrintGraphPort.\n             If a network connection cannot be opened, dumping falls back to file dumping. \n   Disable - Do not dump IGV graphs.\n<\/pre>","name":"PrintGraph","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Print the shape of the heap before and after each collection, if\n+VerboseGC.\n<\/pre>","name":"PrintHeapShape","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print HIR along side LIR as the latter is generated\n<\/pre>","name":"PrintIRWithLIR","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print boot image object hierarchy.\n<\/pre>","name":"PrintImageObjectTree","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Include the LIR as comments with the final assembly.\n<\/pre>","name":"PrintLIRWithAssembly","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Report analysis statistics.\n<\/pre>","name":"PrintPointsToStatistics","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print profiling information when parsing a method's bytecode\n<\/pre>","name":"PrintProfilingInformation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print types used for Java synchronization.\n<\/pre>","name":"PrintSynchronizedAnalysis","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"\"","description":"<pre>The policy to use, must be empty for automatic resolution.\n<\/pre>","name":"PriorityInliningPolicy","prefix":"-XX:","type":"String"},
{"defaultValue":"\"DomainSpecific,BytecodeInterpreter\"","description":"<pre>Comma-separated list of analysis policies for exploring the methods in\nthe call graph and for inlining, empty for no policy.\n<\/pre>","name":"PriorityInliningTuningPolicy","prefix":"-XX:","type":"String"},
{"defaultValue":"true","description":"<pre>Control probabilistic profiling on AMD64\n<\/pre>","name":"ProbabilisticProfiling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"AllocatingMethod","description":"<pre>Control the naming and granularity of the counters when using\nProfileAllocations.\nThe accepted values are:\n        AllocatingMethod - a counter per method\n         InstanceOrArray - one counter for all instance allocations and\n                           one counter for all array allocations \n           AllocatedType - one counter per allocated type\n  AllocatedTypesInMethod - one counter per allocated type, per method\n \n<\/pre>","name":"ProfileAllocationsContext","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Enable profiling of allocation sites.\n<\/pre>","name":"ProfileAllocations","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Track the progress of the static analysis.\n<\/pre>","name":"ProfileAnalysisOperations","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Emit profiling of backedges\n<\/pre>","name":"ProfileBackedges","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"ProfileCompiledMethods","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Track the creation of constant objects.\n<\/pre>","name":"ProfileConstantObjects","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"-1","description":"<pre>Integer greater than zero representing the duration in seconds that\nwill be used to trigger a profile capture. Any integer less than one\ndisables periodic dumps\n<\/pre>","name":"ProfileDumpPeriod","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Emit profiling of invokes\n<\/pre>","name":"ProfileInvokes","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"ProfileLockElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable profiling of monitor operations.\n<\/pre>","name":"ProfileMonitors","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"ProfileOptBulkAllocation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Excludes time spent in invoked methods; measures total time including\nsubcalls when turned off.\n<\/pre>","name":"ProfileSelfTime","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Profile simple methods\n<\/pre>","name":"ProfileSimpleMethods","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"\"default.iprof\"","description":"<pre>Value should point to a profile dump file.\n<\/pre>","name":"ProfilesDumpFile","prefix":"-XX:","type":"String"},
{"defaultValue":"true","name":"PruneLargeDominatorUsageTrees","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.1","description":"<pre>PullThroughPhiOptimization: Percentage in node cost graph size for the\nfloating node duplication budget. Computed relative to the method's\ngraph size.\n<\/pre>","name":"PullThroughPhiCodeSizeIncrease","prefix":"-XX:","type":"Double"},
{"defaultValue":"0","description":"<pre>Number of times an allocation that queues behind a GC will retry before\nprinting a warning\n<\/pre>","name":"QueuedAllocationWarningCount","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","name":"RawConditionalElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"5","name":"ReadEliminationMaxLoopVisits","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Re-associate loop invariants and constants.\n<\/pre>","name":"ReassociateExpressions","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Disable optional dead code eliminations\n<\/pre>","name":"ReduceDCE","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>Select type of reference discovery policy: reference-based(0) or\nreferent-based(1)\n<\/pre>","name":"RefDiscoveryPolicy","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Comma separated list of registers that register allocation is limited\nto.\n<\/pre>","name":"RegisterPressure","prefix":"-XX:","type":"String"},
{"defaultValue":"0.001","description":"<pre>The coefficient used to compute the inlining threshold; the higher, the\nhard to inline.\n<\/pre>","name":"RelativeBenefitInliningCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"true","description":"<pre>Allow a type flow state to contain types not compatible with its\ndeclared type.\n<\/pre>","name":"RelaxTypeFlowStateConstraints","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"RemoveNeverExecutedCode","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable the type flow saturation analysis performance optimization.\n<\/pre>","name":"RemoveSaturatedTypeFlows","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"ReplaceInputsWithConstantsBasedOnStamps","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Dynamically resize (survivor space) promotion LAB's\n<\/pre>","name":"ResizePLAB","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Dynamically resize TLAB size for threads\n<\/pre>","name":"ResizeTLAB","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Try avoid unrolling vectorizable loops.\n<\/pre>","name":"RespectVectorization","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Directory where Java source-files will be placed for the debugger\n<\/pre>","name":"RuntimeSourceDestDir","prefix":"-XX:","type":"String"},
{"defaultValue":"0","description":"<pre>Exit the VM if I can not come to a safepoint in this many nanoseconds.\n0 implies forever.\n<\/pre>","name":"SafepointPromptnessFailureNanos","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>Print a warning if I can not come to a safepoint in this many\nnanoseconds. 0 implies forever.\n<\/pre>","name":"SafepointPromptnessWarningNanos","prefix":"-XX:","type":"Long"},
{"defaultValue":"true","description":"<pre>Object scanning in parallel\n<\/pre>","name":"ScanObjectsParallel","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Simulation can either only process fixed nodes or schedule the graph\nand also process floating nodes.\n<\/pre>","name":"ScheduledDuplicationSimulation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"none","description":"<pre>Writes to the VM log information about the compiler configuration\nselected.\n<\/pre>","name":"ShowConfiguration","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Print the name of each dump file path as it's created.\n<\/pre>","name":"ShowDumpFiles","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Controls whether the source position information of snippets and method\nsubstitutions are exposed to HotSpot. Can be useful when profiling to\nget more precise position information.\n<\/pre>","name":"ShowSubstitutionSourceInfo","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Handle simple cases for inflated monitors in the fast-path.\n<\/pre>","name":"SimpleFastInflatedLocking","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"1","description":"<pre>Maximum number of calls in a simple method\n<\/pre>","name":"SimpleMethodCalls","prefix":"-XX:","type":"Integer"},
{"defaultValue":"256","description":"<pre>Maximum number of nodes in a graph for a simple method\n<\/pre>","name":"SimpleMethodGraphSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>Maximum number of indirect calls in a simple moethod\n<\/pre>","name":"SimpleMethodIndirectCalls","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Use DBDS algorithm to simulate the impact of peeling on a loop.\n<\/pre>","name":"SimulationBasedLoopPeeling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Ignore low frequency branches during simulation.\n<\/pre>","name":"SimulationPruneUnlikelyBranches","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"330","description":"<pre>If the previous low-level graph size of the method exceeds the\nthreshold, it is not inlined.\n<\/pre>","name":"SmallCompiledLowLevelGraphSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0.02","description":"<pre>Reduces the likelihood of exploring call graphs with IR size much\nlarger than the root.\n<\/pre>","name":"SmallRootIrPenaltyCoefficient","prefix":"-XX:","type":"Double"},
{"defaultValue":"false","description":"<pre>Enable counters for various paths in snippets.\n<\/pre>","name":"SnippetCounters","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"1000","description":"<pre>Number of milliseconds per MB of free space in the heap.\n<\/pre>","name":"SoftRefLRUPolicyMSPerMB","prefix":"-XX:","type":"Long"},
{"defaultValue":"None","description":"<pre>Select a strategy to mitigate speculative bounds check bypass (aka\nSpectre-PHT or Spectre V1).\nThis is an experimental option - execution of untrusted code is not supported by GraalVM CE.\nThe accepted values are:\n                  None - No mitigations are used in JIT compiled code.\n            AllTargets - Speculative execution on all conditional branch targets is\n                         stopped using speculative execution barrier instructions.\n          GuardTargets - Branch targets relevant to Java memory safety are instrumented\n                         with barrier instructions. This option has less performance impact\n                         than AllTargets. \n  NonDeoptGuardTargets - Same as GuardTargets, except that branches which deoptimize are not\n                         protected since they can not be executed repeatedly and are thus less\n                         likely to be successfully exploited in an attack.\n          \n                         \nNote that all modes except \"None\" will also instrument branch target blocks containing UNSAFE memory accesses\nwith barrier instructions.\n<\/pre>","name":"SpectrePHTBarriers","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Mask indices to scope access to allocation size after bounds check.\n<\/pre>","name":"SpectrePHTIndexMasking","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Speculates that arrays have exact type to optimize store checks\n<\/pre>","name":"SpeculativeStoreCheck","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>The size of each thread stack at run-time, in bytes.\n<\/pre>","name":"StackSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"\"\"","description":"<pre>Start flight recording with options.\n<\/pre>","name":"StartFlightRecording","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Stress the code emitting explicit exception throwing code.\n<\/pre>","name":"StressExplicitExceptionCode","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Stress the code emitting invokes with explicit exception edges.\n<\/pre>","name":"StressInvokeWithExceptionNode","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Stress the code by emitting reads at earliest instead of latest point.\n<\/pre>","name":"StressTestEarlyReads","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"4096","description":"<pre>String.indexOf invocations will be evaluated at compile time if the\nreceiver is a constant and its length is lower than this value.\n<\/pre>","name":"StringIndexOfLimit","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","name":"SupportJsrBytecodes","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Support OSR compilations with locks. If DeoptAfterOSR is true we can\nper definition not have unbalanced enter/exits mappings. If\nDeoptAfterOSR is false insert artificial monitor enters after the\nOSRStart to have balanced enter/exits in the graph.\n<\/pre>","name":"SupportOSRWithLocks","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"8","description":"<pre>Ratio of eden/survivor space size\n<\/pre>","name":"SurvivorRatio","prefix":"-XX:","type":"Long"},
{"defaultValue":"35","description":"<pre>Allocation averaging weight\n<\/pre>","name":"TLABAllocationWeight","prefix":"-XX:","type":"Integer"},
{"defaultValue":"64","description":"<pre>Maximum TLAB waste at a refill (internal fragmentation)\n<\/pre>","name":"TLABRefillWasteFraction","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>Starting TLAB size (in bytes); zero means set ergonomically\n<\/pre>","name":"TLABSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"4","description":"<pre>Increment allowed waste at slow allocation\n<\/pre>","name":"TLABWasteIncrement","prefix":"-XX:","type":"Long"},
{"defaultValue":"1","description":"<pre>Percentage of Eden that can be wasted\n<\/pre>","name":"TLABWasteTargetPercent","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10","description":"<pre>Target wasted space in last buffer as percent of overall allocation\n<\/pre>","name":"TargetPLABWastePct","prefix":"-XX:","type":"Integer"},
{"defaultValue":"50","description":"<pre>Desired percentage of survivor space used after scavenge\n<\/pre>","name":"TargetSurvivorRatio","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>The number of nanoseconds before tearing down an isolate gives a\nfailure message. 0 implies no message.\n<\/pre>","name":"TearDownFailureNanos","prefix":"-XX:","type":"Long"},
{"defaultValue":"0","description":"<pre>The number of nanoseconds before and between which tearing down an\nisolate gives a warning message. 0 implies no warning.\n<\/pre>","name":"TearDownWarningNanos","prefix":"-XX:","type":"Long"},
{"defaultValue":"16","description":"<pre>Backedge notification frequency\n<\/pre>","name":"TierABackedgeNotifyFreqLog","prefix":"-XX:","type":"Integer"},
{"defaultValue":"12","description":"<pre>Backedge profile probability\n<\/pre>","name":"TierABackedgeProfileProbabilityLog","prefix":"-XX:","type":"Integer"},
{"defaultValue":"-1","description":"<pre>Inlinee invocation notification frequency (-1 means count, but do not\nnotify)\n<\/pre>","name":"TierAInvokeInlineeNotifyFreqLog","prefix":"-XX:","type":"Integer"},
{"defaultValue":"13","description":"<pre>Invocation notification frequency\n<\/pre>","name":"TierAInvokeNotifyFreqLog","prefix":"-XX:","type":"Integer"},
{"defaultValue":"8","description":"<pre>Invocation profile probability\n<\/pre>","name":"TierAInvokeProfileProbabilityLog","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Do profiling and callbacks to tiered runtime\n<\/pre>","name":"TieredAOT","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Profile method execution time.\n<\/pre>","name":"TimeStampProfiling","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Pattern for specifying scopes in which timing is enabled. See the Dump\noption for the pattern syntax. An empty value enables all timers\nunconditionally.\n<\/pre>","name":"Time","prefix":"-XX:","type":"String"},
{"defaultValue":"-1","description":"<pre>Turn on the benchmark counters, and displays the results every n\nmilliseconds\n<\/pre>","name":"TimedDynamicCounters","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Comma separated names of timers that are enabled irrespective of the\nvalue for Time option. An empty value enables all timers\nunconditionally.\n<\/pre>","name":"Timers","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Enables detailed tracing of auxiliary image events.\n<\/pre>","name":"TraceAuxiliaryImageClassHistogram","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enables detailed tracing of auxiliary image events.\n<\/pre>","name":"TraceAuxiliaryImageReferenceTree","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>The trace level for the bytecode parser. A value of 1 enables\ninstruction tracing and any greater value emits a frame state trace\njust prior to each instruction trace.Instruction tracing output from\nmultiple compiler threads will be interleaved so use of this option\nmake most sense for single threaded compilation. The MethodFilter\noption can be used to refine tracing to selected methods.\n<\/pre>","name":"TraceBytecodeParserLevel","prefix":"-XX:","type":"Integer"},
{"defaultValue":"false","description":"<pre>Print logging information for runtime code cache modifications\n<\/pre>","name":"TraceCodeCache","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print verbose logging information for every deoptimization\n<\/pre>","name":"TraceDeoptimizationDetails","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print logging information for every deoptimization\n<\/pre>","name":"TraceDeoptimization","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"TraceEscapeAnalysis","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Trace execution of stub used to handle an exception thrown by a callee.\n<\/pre>","name":"TraceExceptionHandlerStub","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Trace heap chunks during collections, if +VerboseGC and\n+PrintHeapShape.\n<\/pre>","name":"TraceHeapChunks","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Traces inlining performed during bytecode parsing.\n<\/pre>","name":"TraceInlineDuringParsing","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable inlining decision tracing in stubs and snippets.\n<\/pre>","name":"TraceInliningForStubsAndSnippets","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable tracing of inlining decisions.\nOutput format:\n  compilation of 'Signature of the compilation root method':\n    at 'Signature of the root method' ['Bytecode index']: <'Phase'> 'Child method signature': 'Decision made about this callsite'\n      at 'Signature of the child method' ['Bytecode index']: \n         |--<'Phase 1'> 'Grandchild method signature': 'First decision made about this callsite'\n         \\--<'Phase 2'> 'Grandchild method signature': 'Second decision made about this callsite'\n      at 'Signature of the child method' ['Bytecode index']: <'Phase'> 'Another grandchild method signature': 'The only decision made about this callsite.'\n<\/pre>","name":"TraceInlining","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>The trace level for the LIR generator\n<\/pre>","name":"TraceLIRGeneratorLevel","prefix":"-XX:","type":"Integer"},
{"defaultValue":"null","description":"<pre>Enables tracing of profiling info when read by JVMCI.\nEmpty value: trace all methods\nNon-empty value: trace methods whose fully qualified name contains the value.\n<\/pre>","name":"TraceMethodDataFilter","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Trace monitor operations in methods whose fully qualified name contains\nthis substring.\n<\/pre>","name":"TraceMonitorsMethodFilter","prefix":"-XX:","type":"String"},
{"defaultValue":"null","description":"<pre>Trace monitor operations on objects whose type contains this substring.\n<\/pre>","name":"TraceMonitorsTypeFilter","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Traces use of plugins during bytecode parsing.\n<\/pre>","name":"TraceParserPlugins","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Trace execution of the stub that routes an exception to a handler in\nthe calling frame.\n<\/pre>","name":"TraceUnwindStub","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Track the callers for methods and accessing methods for fields.\n<\/pre>","name":"TrackAccessChain","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable (if Count is enabled) graph size tracking during every\nduplication iteration.\n<\/pre>","name":"TrackGraphSizesInDuplication","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"none","description":"<pre>Track inlining statistics (inlining duration, call tree size, compiler\nnode counts, and the number of callsites). One of: none, interactive\n<\/pre>","name":"TrackInliningStatistics","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Track the input for type flows.\n<\/pre>","name":"TrackInputFlows","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Pattern for specifying scopes in which memory use tracking is enabled.\nSee the Dump option for the pattern syntax. An empty value enables all\nmemory use trackers unconditionally.\n<\/pre>","name":"TrackMemUse","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Track source stack trace where a node was inserted into the graph.\n<\/pre>","name":"TrackNodeInsertion","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Track the NodeSourcePosition.\n<\/pre>","name":"TrackNodeSourcePosition","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"10","description":"<pre>Graphs with less than this number of nodes are trivial and therefore\nalways inlined.\n<\/pre>","name":"TrivialInliningSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"512.0","description":"<pre>Loop peeling will consider any loop with a size (in terms of estimated\nmachine instructions) below this value to be a prime candidate for\npeeling. Larger loops will only be considered for peeling if the\nsimulated benefit of peeling is relatively high. The larger the loop,\nthe greater the expected benefit has to be.\n<\/pre>","name":"TrivialLoopSizeLimitForPeeling","prefix":"-XX:","type":"Double"},
{"defaultValue":"null","description":"<pre>Select a compiler configuration for Truffle compilation (default: use\nGraal system compiler configuration).\n<\/pre>","name":"TruffleCompilerConfiguration","prefix":"-XX:","type":"String"},
{"defaultValue":"true","description":"<pre>Determines whether to treat final fields with default values as\nconstant.\n<\/pre>","name":"TrustFinalDefaultFields","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>PullThroughPhiOptimization: Enable floating node duplication over\nmultiple phi nodes at once.\n<\/pre>","name":"TryExplodeOverPhis","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>PullThroughPhiOptimization: Enable floating node duplication over phis\nwhere the target node has different phis as input.\n<\/pre>","name":"TryPhiPhiPulls","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0.0","description":"<pre>Increases or decreases the time spent exploring inlining opportunities\nunder the assumption that more time results in better peak performance\nand less time reduces time to reach (a lower) peak performance. The\nvalue of the option is clamped between -1 and 1 inclusive. Anything\nbelow 0, reduces the exploration time and anything above 0 increases\nexploration time. Note that this option is only a heuristic and should\nbe tuned for any specific application.\n<\/pre>","name":"TuneInlinerExploration","prefix":"-XX:","type":"Double"},
{"defaultValue":"2","description":"<pre>The maximum number of profiled types that will be used when compiling a\nprofiled type check. Note that TypeCheckMinProfileHitProbability also\ninfluences whether profiling info is used in compiled type checks.\n<\/pre>","name":"TypeCheckMaxHints","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0.5","description":"<pre>If the probability that a type check will hit one the profiled types\n(up to TypeCheckMaxHints) is below this value, the type check will be\ncompiled without profiling info\n<\/pre>","name":"TypeCheckMinProfileHitProbability","prefix":"-XX:","type":"Double"},
{"defaultValue":"0","description":"<pre>How many levels of inputs to print. A value of 0 prints only the target\nflow.\n<\/pre>","name":"TypeFlowPrinterInRadius","prefix":"-XX:","type":"Integer"},
{"defaultValue":"0","description":"<pre>How many levels of outputs to print. A value of 0 prints only the\ntarget flow.\n<\/pre>","name":"TypeFlowPrinterOutRadius","prefix":"-XX:","type":"Integer"},
{"defaultValue":"20","description":"<pre>The maximum number of types recorded in a type flow. -1 indicates no\nlimitation.\n<\/pre>","name":"TypeFlowSaturationCutoff","prefix":"-XX:","type":"Integer"},
{"defaultValue":"200","description":"<pre>Denotes the call graph size that is considered medium size.\n<\/pre>","name":"TypicalCallGraphSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"70","description":"<pre>The increase in estimated typical graph size after inlining, per each\nextra invoke.\n<\/pre>","name":"TypicalGraphSizeInvokeBonus","prefix":"-XX:","type":"Integer"},
{"defaultValue":"10000","description":"<pre>The maximum in estimated inlined typical graph size.\n<\/pre>","name":"TypicalGraphSizeMax","prefix":"-XX:","type":"Integer"},
{"defaultValue":"3250","description":"<pre>The typical graph size at which inlining pressure must start growing.\n<\/pre>","name":"TypicalGraphSize","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Report unresolved elements as errors.\n<\/pre>","name":"UnresolvedIsError","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"16","name":"UnrollMaxIterations","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Unroll loops with multiple loop ends.\n<\/pre>","name":"UnrollMultiEndLoops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Unroll loops with multiple loop exits.\n<\/pre>","name":"UnrollMultiExitLoops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Force branch instructions to align with 32-bytes boundary, to mitigate\nthe jcc erratum. See\nhttps://www.intel.com/content/dam/support/us/en/documents/processors/mitigations-jump-conditional-code-erratum.pdf\nfor more details. If not set explicitly, the default value will be\ndetermined according to the CPU model.\n<\/pre>","name":"UseBranchesWithin32ByteBoundary","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enables CompilationStatistics.\n<\/pre>","name":"UseCompilationStatistics","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Dynamically choose the number of threads up to a maximum of\nParallelGCThreads parallel collectors will use for garbage collection\nwork\n<\/pre>","name":"UseDynamicNumberOfGCThreads","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Encode and decode snippets and substitutions before parsing to test\nlibgraal code path. This option is ignored in the context of libgraal.\n<\/pre>","name":"UseEncodedGraphs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"UseExceptionProbability","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use Graal-generated stubs for complicated LIR operations instead of\nembedding all the emitted code.\n<\/pre>","name":"UseGraalStubs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Turn on graph caching.\n<\/pre>","name":"UseGraphCache","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"UseLoopLimitChecks","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Flag to disable jvmstat instrumentation for performance testing.\n<\/pre>","name":"UsePerfData","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use priority-based inlining.\n<\/pre>","name":"UsePriorityInlining","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>          \n<\/pre>","name":"UseProfilingInformation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use a cache for snippet graphs.\n<\/pre>","name":"UseSnippetGraphCache","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use a LRU cache for snippet templates.\n<\/pre>","name":"UseSnippetTemplateCache","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use traps for null checks instead of explicit null-checks\n<\/pre>","name":"UseTrappingNullChecks","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","name":"UseTypeCheckHints","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Use absolute path for source-filenames in VTune events.\n<\/pre>","name":"VTuneAbsoluteFilenames","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorized array copy intrinsics\n<\/pre>","name":"VectorIntrinsics","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"1","description":"<pre>Unroll vectorized loops\n<\/pre>","name":"VectorUnroll","prefix":"-XX:","type":"Integer"},
{"defaultValue":"true","description":"<pre>Enable vectorization.\n<\/pre>","name":"Vectorization","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorized array initialization\n<\/pre>","name":"VectorizeAllocation","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of conditional code.\n<\/pre>","name":"VectorizeConditional","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of loops with conditional deopts before writes.\n<\/pre>","name":"VectorizeDeopts","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of loops implementing a higher-order 'fold'\nfunction.\n<\/pre>","name":"VectorizeFoldShaped","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of vector gather operations.\n<\/pre>","name":"VectorizeGather","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of loops\n<\/pre>","name":"VectorizeLoops","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of loops implementing a higher-order 'map'\nfunction.\n<\/pre>","name":"VectorizeMapShaped","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of loops with negative strides.\n<\/pre>","name":"VectorizeNegativeStride","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Enable detection of SIMD patterns\n<\/pre>","name":"VectorizeSIMD","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of loops with safepoints.\n<\/pre>","name":"VectorizeSafepoints","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Enable vectorization of sequence values.\n<\/pre>","name":"VectorizeSequence","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Print more information about the heap before and after each collection\n<\/pre>","name":"VerboseGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify memory system after GC\n<\/pre>","name":"VerifyAfterGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Emit extra code to dynamically check monitor operations are balanced.\n<\/pre>","name":"VerifyBalancedMonitors","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify memory system before GC\n<\/pre>","name":"VerifyBeforeGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"VerifyDuplicationOperations","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify memory system during GC (between phases)\n<\/pre>","name":"VerifyDuringGC","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"0","description":"<pre>GC invoke count where +VerifyHeap kicks in\n<\/pre>","name":"VerifyGCStartAt","prefix":"-XX:","type":"Long"},
{"defaultValue":"false","description":"<pre>Perform expensive verification of graph inputs, usages, successors and\npredecessors\n<\/pre>","name":"VerifyGraalGraphEdges","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"true","description":"<pre>Verify graphs often during compilation when assertions are turned on\n<\/pre>","name":"VerifyGraalGraphs","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify before - after relation of the relative, computed, code size of\na graph\n<\/pre>","name":"VerifyGraalPhasesSize","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Perform platform dependent validation of the Java heap at returns\n<\/pre>","name":"VerifyHeapAtReturn","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify that there are no new unused nodes when performing killCFG\n<\/pre>","name":"VerifyKillCFGUnusedNodes","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","name":"VerifyPhases","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Verify GC remembered sets\n<\/pre>","name":"VerifyRememberedSets","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Add code to verify that eliminated barriers weren't needed.\n<\/pre>","name":"VerifyWriteBarrierElimination","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"null","description":"<pre>Pattern for specifying scopes in which logging is enabled. See the Dump\noption for the pattern syntax.\n<\/pre>","name":"Verify","prefix":"-XX:","type":"String"},
{"defaultValue":"false","description":"<pre>Allocate code cache with write access, allowing inlining of objects\n<\/pre>","name":"WriteableCodeCache","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"4096","description":"<pre>Size of young gen promotion LAB's (in HeapWords)\n<\/pre>","name":"YoungPLABSize","prefix":"-XX:","type":"Long"},
{"defaultValue":"false","name":"ZapStackOnMethodEntry","prefix":"-XX:","type":"Boolean"},
{"defaultValue":"false","description":"<pre>Zero out the newly created TLAB\n<\/pre>","name":"ZeroTLAB","prefix":"-XX:","type":"Boolean"}
] }